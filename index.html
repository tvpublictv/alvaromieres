<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0">
    <title>Alvaro Mieres</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    
    <!-- LOADING SCREEN -->
    <div id="loading-screen">
        <div class="loading-container">
            <h1>alvaro mieres</h1>
            <div class="loading-bar">
            <div class="loading-fill" id="loading-fill"></div>
                
        </div>
        </div>
    </div>

    
    <!-- MAIN PAGE -->
    <div id="content">

        <!-- Header -->
        <header>
            
            <!-- Date -->
            <div class="date" id="dateDisplay">
                <div class="year" id="yearDisplay"></div>
                <div class="month" id="monthDisplay"></div>
            </div>
            
            <!-- Index -->
            <nav class="navigation">
                <ul class="pill-box">
                    <li class="pill pill1">Architecture</li>
                    <li class="pill pill2">Research</li>
                    <li class="pill pill3">Other</li>
                    <li class="pill pill4">Art</li>
                    <li class="pill pill5">Visual</li>
            </ul></nav>
        
               
            
        </header>

        <!-- Header -->
        <!-- Overlays -->
        <div class="gradient-overlay"></div>
        <div class="background-color"></div>

        <!-- Circle Pattern -->
        <div id="background" class="background disabled">
            
        <div id="card" class="card" style="top: 550vh; left: 170vw;"></div>
    
        
        
        </div>
        
        
        
        <!-- AYUDAS -->
        <div id="vertical-line" class="verticalline"></div>
    </div>

    
    
    <!-- SCRIPTS -->
    
    <script>
        
        
        // Disable the right-click Context menu
        document.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });
        // Remove scroll cache
        if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
        }
        
        
        
        // --- LOADING BAR
        
        function animateLoadingBar() {
            const fill = document.getElementById('loading-fill');

            setTimeout(() => {
                fill.style.transitionDuration = '1500';
                fill.style.width = '100%';
            }, 250);
        }

        
        
        // --- ONLOAD ANIMATIONS

        window.onload = function () {
            
            
            
            
            animateLoadingBar();

            
            //Loading screen Fade Out
            setTimeout(function () {
                document.getElementById('loading-screen').classList.add('fade-out');

                //Content Fade In
                setTimeout(function () {
                    document.getElementById('loading-screen').style.display = 'none';
                    document.getElementById('content').classList.add('fade-in');

                    
                }, 1000);
            }, 2500);
            
            
            setTimeout(function () {
                
                const patternSize = document.getElementById('background');
                    //patternSize.style.width = '120vw';  // Change width
                    //patternSize.style.height = '900vh'; //hay que poner 100 mas

            }, 4500);
        };
         

        
        // --- SCROLL
        
        const draggableContent = document.getElementById('background');
        let scrollMouseX = 0;
        let scrollMouseY = 0;

        let draggableContentX = 0;
        let draggableContentY = 0;

        let offsetX = 0;
        let offsetY = 0;

        const scrollDelay = 0.05;
        let isScrolling = false;

        let animationFrameId = null;


        // Get the current transform translate values
        function getTranslateValues(element) {
            const style = window.getComputedStyle(element);
            const matrix = new WebKitCSSMatrix(style.transform);
            return {
                x: matrix.m41,
                y: matrix.m42
            };
        }

        // Start scrolling
        draggableContent.addEventListener('mousedown', (event) => {
            isScrolling = true;

            // Capture the initial mouse positions
            scrollMouseX = event.clientX;
            scrollMouseY = event.clientY;

            // Get current translate values of the draggable content
            const translate = getTranslateValues(draggableContent);
            draggableContentX = translate.x;
            draggableContentY = translate.y;

            // Calculate offsets relative to the current mouse position
            offsetX = event.clientX - draggableContentX;
            offsetY = event.clientY - draggableContentY;

            // Prevent default behavior (like text selection)
            event.preventDefault();
            event.stopPropagation();

            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            // Start the animation loop
            requestAnimationFrame(scroll);
        });

        // Track mouse movement
        document.addEventListener('mousemove', (event) => {
            if (isScrolling) {
                scrollMouseX = event.clientX;
                scrollMouseY = event.clientY;
            }
        });

        // Stop scrolling
        document.addEventListener('mouseup', () => {
            isScrolling = false;
        });

        // Smoothly move the draggable content
        function scroll() {
            if (isScrolling) {
                // Calculate new positions based on mouse movement
                draggableContentX += (scrollMouseX - draggableContentX - offsetX) * scrollDelay;
                draggableContentY += (scrollMouseY - draggableContentY - offsetY) * scrollDelay;       
            } else {
                // Calculate new positions based on mouse movement
                draggableContentX += (scrollMouseX - draggableContentX - offsetX) * scrollDelay;
                draggableContentY += (scrollMouseY - draggableContentY - offsetY) * scrollDelay;       
            }
            
            // Define boundaries in vw and vh
            const minX = -0.2 * window.innerWidth;
            const maxX = 0.2 * window.innerWidth;  
            const minY = -3 * window.innerHeight;
            const maxY = 3 * window.innerHeight; 
            
            // Clamp the draggable content position within defined boundaries
            draggableContentX = Math.max(minX, Math.min(maxX, draggableContentX));
            draggableContentY = Math.max(minY, Math.min(maxY, draggableContentY));

            // Set draggable content position using translate
            draggableContent.style.transform = `translate(${draggableContentX}px, ${draggableContentY}px)`;

            // Continue the animation loop only if still moving
            if (isScrolling || Math.abs(scrollMouseX - draggableContentX - offsetX) > 10 || Math.abs(scrollMouseY - draggableContentY - offsetY) > 10) {
                animationFrameId = requestAnimationFrame(scroll);
            } else {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        
    
          
        
        
        // --- GRID SHADOW ---
        const sizeFactor = 5;
        const circleShadow = document.querySelector('.background');
        let isTouching = false; // Track whether there is a touch input
        let shadowX = 0; // X offset for shadow
        let shadowY = 0; // Y offset for shadow
        const returnSpeed = 0.1; // Speed at which the shadow returns to center

        // Function to update shadow position based on mouse or touch input
        function updateShadow(mouseX, mouseY) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            const deltaX = -(mouseX - centerX) / window.innerWidth;
            const deltaY = -(mouseY - centerY) / window.innerHeight;

            const offset = `min(0.2vw, 0.2vh)`;
            const shadowOffsetX = `calc(${offset} * ${deltaX * sizeFactor})`;
            const shadowOffsetY = `calc(${offset} * ${deltaY * sizeFactor})`;

            const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);
            const standardDeviation = `calc(${offset} * ${distance * 1.66})`; // Scale the distance as needed

            circleShadow.style.filter = `drop-shadow(${shadowOffsetX} ${shadowOffsetY} ${standardDeviation} #7f7f7f)`;
        }

        // Function to animate shadow returning to center
        function animateReturnToCenter() {
            if (!isTouching) {
                // Smoothly return shadow to center
                shadowX *= (1 - returnSpeed);
                shadowY *= (1 - returnSpeed);

                const offset = `min(0.2vw, 0.2vh)`;
                const shadowOffsetX = `calc(${offset} * ${shadowX * sizeFactor})`;
                const shadowOffsetY = `calc(${offset} * ${shadowY * sizeFactor})`;

                circleShadow.style.filter = `drop-shadow(${shadowOffsetX} ${shadowOffsetY} 0 #7f7f7f)`; // Set shadow size to 0 for center

                // Continue animation until shadow is close enough to center
                if (Math.abs(shadowX) > 0.01 || Math.abs(shadowY) > 0.01) {
                    requestAnimationFrame(animateReturnToCenter);
                }
            }
        }

        // Mouse events for moving the shadow
        document.addEventListener('mousemove', (event) => {
            isTouching = false; // Mouse interaction
            updateShadow(event.clientX, event.clientY);
        });

        // Touch events for moving the shadow
        document.addEventListener('touchstart', (event) => {
            isTouching = true; // Set to true when touching
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            shadowX = -(touchX - (window.innerWidth / 2)) / window.innerWidth;
            shadowY = -(touchY - (window.innerHeight / 2)) / window.innerHeight;
            updateShadow(touchX, touchY);
        });

        document.addEventListener('touchmove', (event) => {
            if (isTouching) {
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                shadowX = -(touchX - (window.innerWidth / 2)) / window.innerWidth;
                shadowY = -(touchY - (window.innerHeight / 2)) / window.innerHeight;
                updateShadow(touchX, touchY);
            }
        });

        document.addEventListener('touchend', () => {
            isTouching = false; // Touch ended
            animateReturnToCenter(); // Start animation to return shadow to center
        });

        // Initialize shadow to center on page load
        animateReturnToCenter();
        
        
        
        
        // --- DATE ---
        
        const startYear = 2024;
        const startPercentage = 0.13;
        
        const yearDisplay = document.getElementById('yearDisplay');
        const monthDisplay = document.getElementById('monthDisplay');
    

        // Custom for each year
        const scrollPercentages = {
            2024: 0.65,
            2023: 0.35,
            2022: 0.10,
            2021: 0.10,
            2020: 0.10,
            2019: 0.10,
            2018: 0.10,
            // Max is at 133% 
        };

        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];

        const totalYears = Object.keys(scrollPercentages).length;

        function updateDate() {
            const scrollY = window.scrollY;
            const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
    
            // Total page scrolled percentage
            const scrollPercent = (scrollY / totalScrollHeight)+startPercentage;

            let cumulativeScrollPercent = 0;
            let currentYear = startYear;
            let monthsPassed = 0;

            // Year we're in based on scroll percentage
            for (let year = startYear; year >= startYear - totalYears + 1; year--) {
                const yearScrollPercent = scrollPercentages[year];
                cumulativeScrollPercent += yearScrollPercent;

            if (scrollPercent <= cumulativeScrollPercent) {
                currentYear = year;

                // Calculate how many months have passed in the current year
                const yearScrollRange = yearScrollPercent;
                const yearScrollStart = cumulativeScrollPercent - yearScrollRange;
                const yearScrollProgress = (scrollPercent - yearScrollStart) / yearScrollRange;

                // Convert the scroll progress to months (0 to 11, reversed)
                monthsPassed = Math.floor((1 - yearScrollProgress) * 12);
                break;
            }
            }

        // Ensure monthsPassed wraps around within 0-11 range
        monthsPassed = (monthsPassed + 12) % 12;

        // Display the current year and month
        yearDisplay.innerHTML = currentYear;
        monthDisplay.innerHTML = monthNames[monthsPassed];
        }

        // Call updateDate on scroll
        window.addEventListener('load', updateDate);


        
        
         // --- DRAGS ---  
        
        const cards = document.querySelectorAll('.card');
        const relativePos = document.querySelector('.background');
        const dragDelay = 0.05; 
        const cardRadiusX = 25;
        const cardRadiusY = 25;
        
        cards.forEach(card => {
            let isDragging = false;
            let dragMouseX = 0;
            let dragMouseY = 0;
            
            let relativeX = -relativePos.offsetLeft;
            let relativeY = -relativePos.offsetTop;
            
            let cardX = (card.offsetLeft + cardRadiusX - relativeX); 
            let cardY = (card.offsetTop + cardRadiusY - relativeY);

            let originalCardX = card.offsetLeft; 
            let originalCardY = card.offsetTop;
            
            
          
            let animationFrameId = null; 


            // Start dragging
            card.addEventListener('mousedown', (event) => {
                
                isDragging = true; 
                

                dragMouseX = event.clientX; 
                dragMouseY = event.clientY; 

                // Prevent default behavior
                event.preventDefault(); 
                event.stopPropagation(); // Prevent event bubbling

                animationFrameId = requestAnimationFrame(animateDrag);
            });


            document.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    dragMouseX = event.clientX;
                    dragMouseY = event.clientY;
                }
            });


            // Stop dragging
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });



            function animateDrag() {
                if (isDragging) {

                    cardX += (dragMouseX - cardX) * dragDelay; 
                    cardY += (dragMouseY - cardY) * dragDelay; 

                } else {
                    // Snap to last position when mouse is released
                    cardX += (dragMouseX - cardX) * dragDelay; 
                    cardY += (dragMouseY - cardY) * dragDelay;
                }


                card.style.transform = `translate(${cardX-originalCardX-cardRadiusX+relativeX}px, ${cardY-originalCardY-cardRadiusY+relativeY}px)`;


                // Continue the animation loop only if still moving
                if (isDragging || Math.abs(dragMouseX - cardX) > 0.01 || Math.abs(dragMouseY - cardY) > 0.01) {
                    animationFrameId = requestAnimationFrame(animateDrag);
                } else {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        });
        
       
        
        
        
        // --- CENTER THE NAV ---   
        const pill1 = document.querySelector('.pill1');
        const pillBox = document.querySelector('.pill-box');
    
        function updateOffset() {
        
            // Get the total width of the viewport
            const totalWidth = window.innerWidth;

            // Get the bounding rectangle of pill1
            const pill1Rect = pill1.getBoundingClientRect();

            // Calculate the center of pill1
            const pill1Center = pill1Rect.left + (pill1Rect.width / 2);

            // Calculate the difference between center of viewport and center of pill1
            const offset = (totalWidth / 2) - pill1Center;
            
            
            pillBox.style.transform = `translateX(${offset}px)`;  
    }

        window.addEventListener('load', () => {
        setTimeout(updateOffset, 0);
    });

    
    
    </script>
</body>

</html>
