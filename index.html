<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=0">
    <title>Alvaro Mieres</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    
    <!-- LOADING SCREEN -->
    <div id="loading-screen">
        <div class="loading-container">
            <h1>alvaro mieres</h1>
            <div class="loading-bar">
            <div class="loading-fill" id="loading-fill"></div>
                
        </div>
        </div>
    </div>

    
    <!-- MAIN PAGE -->
    <div id="content">

        <!-- Header -->
        <header>
            
            <!-- Date -->
            <div class="date" id="dateDisplay">
                <div class="year" id="yearDisplay"></div>
                <div class="month" id="monthDisplay"></div>
            </div>
            
            <!-- Index -->
            <nav class="navigation">
                <ul class="pill-box">
                    <li class="pill pill1">Architecture</li>
                    <li class="pill pill2">Research</li>
                    <li class="pill pill3">Other</li>
                    <li class="pill pill4">Art</li>
                    <li class="pill pill5">Visual</li>
            </ul></nav>
        
               
            
        </header>

        <!-- Elipse mask overlay -->
        <div id="main" class="scrollable-content"></div>
        
        <!-- Elipse mask overlay -->
        <div class="gradient-overlay"></div>

        <!-- Circle Pattern -->
        <div id="circle-pattern" class="circle disabled"></div>
        
        <!-- AYUDAS -->
        <div class="verticalline"></div>
        <div class="display"></div>
    </div>

    
    
    <!-- SCRIPTS -->
    
    <script>
        
        
        
        // --- LOADING BAR
        
        function animateLoadingBar() {
            const fill = document.getElementById('loading-fill');

            setTimeout(() => {
                fill.style.transitionDuration = '1500';
                fill.style.width = '100%';
            }, 250);
        }

        
        
        // --- ONLOAD ANIMATIONS

        window.onload = function () {
            
            // Center the viewport horizontally
            const centerX = (document.body.scrollWidth - window.innerWidth) / 2;
            window.scrollTo(centerX, 0);
            
            animateLoadingBar();
            

            

            
            //Loading screen Fade Out
            setTimeout(function () {
                document.getElementById('loading-screen').classList.add('fade-out');

                //Content Fade In
                setTimeout(function () {
                    document.getElementById('loading-screen').style.display = 'none';
                    document.getElementById('content').classList.add('fade-in');
                    document.querySelector('header').style.display = 'flex';

                    
                }, 1000);
            }, 2000);
            
            
            setTimeout(function () {
                
                const patternSize = document.getElementById('circle-pattern');
                    patternSize.style.width = '120vw';  // Change width
                    patternSize.style.height = '500vh'; //hay que poner 100 mas
                    patternSize.style.left = '-5vw';

                    setupMovementHandlers();

            }, 4000);
        };
         
        // Reset scroll position before the page is unloaded (for refresh)
        window.onbeforeunload = function() {
            const centerX = (document.body.scrollWidth - window.innerWidth) / 2;
            window.scrollTo(centerX, 0);
        }

        
        
        // --- GRID SHADOW ---
        const sizeFactor = 5;
        const circle = document.querySelector('.circle');
        let isTouching = false; // Track whether there is a touch input
        let shadowX = 0; // X offset for shadow
        let shadowY = 0; // Y offset for shadow
        const returnSpeed = 0.1; // Speed at which the shadow returns to center

        // Function to update shadow position based on mouse or touch input
        function updateShadow(mouseX, mouseY) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            const deltaX = -(mouseX - centerX) / window.innerWidth;
            const deltaY = -(mouseY - centerY) / window.innerHeight;

            const offset = `min(0.2vw, 0.2vh)`;
            const shadowOffsetX = `calc(${offset} * ${deltaX * sizeFactor})`;
            const shadowOffsetY = `calc(${offset} * ${deltaY * sizeFactor})`;

            const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);
            const standardDeviation = `calc(${offset} * ${distance * 1.66})`; // Scale the distance as needed

            circle.style.filter = `drop-shadow(${shadowOffsetX} ${shadowOffsetY} ${standardDeviation} #7f7f7f)`;
        }

        // Function to animate shadow returning to center
        function animateReturnToCenter() {
            if (!isTouching) {
                // Smoothly return shadow to center
                shadowX *= (1 - returnSpeed);
                shadowY *= (1 - returnSpeed);

                const offset = `min(0.2vw, 0.2vh)`;
                const shadowOffsetX = `calc(${offset} * ${shadowX * sizeFactor})`;
                const shadowOffsetY = `calc(${offset} * ${shadowY * sizeFactor})`;

                circle.style.filter = `drop-shadow(${shadowOffsetX} ${shadowOffsetY} 0 #7f7f7f)`; // Set shadow size to 0 for center

                // Continue animation until shadow is close enough to center
                if (Math.abs(shadowX) > 0.01 || Math.abs(shadowY) > 0.01) {
                    requestAnimationFrame(animateReturnToCenter);
                }
            }
        }

        // Mouse events for moving the shadow
        document.addEventListener('mousemove', (event) => {
            isTouching = false; // Mouse interaction
            updateShadow(event.clientX, event.clientY);
        });

        // Touch events for moving the shadow
        document.addEventListener('touchstart', (event) => {
            isTouching = true; // Set to true when touching
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            shadowX = -(touchX - (window.innerWidth / 2)) / window.innerWidth;
            shadowY = -(touchY - (window.innerHeight / 2)) / window.innerHeight;
            updateShadow(touchX, touchY);
        });

        document.addEventListener('touchmove', (event) => {
            if (isTouching) {
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                shadowX = -(touchX - (window.innerWidth / 2)) / window.innerWidth;
                shadowY = -(touchY - (window.innerHeight / 2)) / window.innerHeight;
                updateShadow(touchX, touchY);
            }
        });

        document.addEventListener('touchend', () => {
            isTouching = false; // Touch ended
            animateReturnToCenter(); // Start animation to return shadow to center
        });

        // Initialize shadow to center on page load
        animateReturnToCenter();
        
        
        
        // --- DATE ---
        
        const startYear = 2024;
        const startPercentage = 0.13;
        
        const yearDisplay = document.getElementById('yearDisplay');
        const monthDisplay = document.getElementById('monthDisplay');

        // Custom for each year
        const scrollPercentages = {
            2024: 0.65,
            2023: 0.35,
            2022: 0.10,
            2021: 0.10,
            2020: 0.10,
            2019: 0.10,
            2018: 0.10,
            // Max is at 133% 
        };

        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];

        const totalYears = Object.keys(scrollPercentages).length;

        function updateDate() {
            const scrollY = window.scrollY;
            const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
    
            // Total page scrolled percentage
            const scrollPercent = (scrollY / totalScrollHeight)+startPercentage;

            let cumulativeScrollPercent = 0;
            let currentYear = startYear;
            let monthsPassed = 0;

            // Year we're in based on scroll percentage
            for (let year = startYear; year >= startYear - totalYears + 1; year--) {
                const yearScrollPercent = scrollPercentages[year];
                cumulativeScrollPercent += yearScrollPercent;

            if (scrollPercent <= cumulativeScrollPercent) {
                currentYear = year;

                // Calculate how many months have passed in the current year
                const yearScrollRange = yearScrollPercent;
                const yearScrollStart = cumulativeScrollPercent - yearScrollRange;
                const yearScrollProgress = (scrollPercent - yearScrollStart) / yearScrollRange;

                // Convert the scroll progress to months (0 to 11, reversed)
                monthsPassed = Math.floor((1 - yearScrollProgress) * 12);
                break;
            }
            }

        // Ensure monthsPassed wraps around within 0-11 range
        monthsPassed = (monthsPassed + 12) % 12;

        // Display the current year and month
        yearDisplay.innerHTML = currentYear;
        monthDisplay.innerHTML = monthNames[monthsPassed];
        }

        // Call updateDate on scroll
        window.addEventListener('scroll', updateDate);


        
        
        // --- SCROLLING ---
        function setupMovementHandlers() {
            let isDragging = false;
            let startY, startX;
            let scrollSpeedY = 0;
            let scrollSpeedX = 0;
            let targetScrollSpeedY = 0;
            let targetScrollSpeedX = 0;
            const acceleration = 0.02;
            const deceleration = 0.95; // Standard deceleration
            const edgeDeceleration = 0.95; // Stronger deceleration when at edges
            const minDeceleration = 0.01; // Minimum speed before clamping to zero

            // Define maximum scrolling speed based on the minimum of 5vw and 5vh
            const maxScrollSpeed = Math.min(5 * window.innerWidth / 100, 5 * window.innerHeight / 100); // Max scrolling speed in pixels

            // Define different thresholds for early deceleration
            const topThreshold = 20 * (window.innerHeight / 100);   
            const bottomThreshold = -80 * (window.innerHeight / 100); // -100 would be 0
            const sideThreshold = 15 * (window.innerWidth / 100);

            function startDrag(e) {
                isDragging = true;
                // Use clientY/clientX for mouse events, or changed touches[0] for touch events
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                startX = e.touches ? e.touches[0].clientX : e.clientX;
            }

            function endDrag() {
                isDragging = false;
            }

            function move(e) {
                if (!isDragging) return;

                const deltaY = startY - (e.touches ? e.touches[0].clientY : e.clientY);
                const deltaX = startX - (e.touches ? e.touches[0].clientX : e.clientX);
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                startX = e.touches ? e.touches[0].clientX : e.clientX;

                // Apply the vertical speed factor to increase Y speed
                targetScrollSpeedY = deltaY * 1;
                targetScrollSpeedX = deltaX * 1;
            }

            function smoothScroll() {
                // Check current scroll positions
                const scrollTop = window.scrollY;
                const scrollLeft = window.scrollX;
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;
                const documentHeight = document.body.scrollHeight;
                const documentWidth = document.body.scrollWidth;

                // Implement early deceleration when approaching the edges with different thresholds
                if (scrollTop <= topThreshold && scrollSpeedY < 0) {
                    scrollSpeedY *= 0.7; // Stronger deceleration when scrolling up close to the top
                }
                if (scrollTop + windowHeight >= documentHeight - bottomThreshold && scrollSpeedY > 0) {
                    scrollSpeedY *= 0.7; // Stronger deceleration when scrolling down close to the bottom
                }
                if (scrollLeft <= sideThreshold && scrollSpeedX < 0) {
                    scrollSpeedX *= 0.7; // Stronger deceleration when scrolling left close to the left edge
                }
                if (scrollLeft + windowWidth >= documentWidth - sideThreshold && scrollSpeedX > 0) {
                    scrollSpeedX *= 0.7; // Stronger deceleration when scrolling right close to the right edge
                }

                // Apply faster vertical speed reduction when near the left or right edges
                if (scrollLeft <= sideThreshold || scrollLeft + windowWidth >= documentWidth - sideThreshold) {
                    scrollSpeedY *= edgeDeceleration; // Apply stronger deceleration to vertical speed
                }

                if (isDragging) {
                    scrollSpeedY += (targetScrollSpeedY - scrollSpeedY) * acceleration;
                    scrollSpeedX += (targetScrollSpeedX - scrollSpeedX) * acceleration;

                    // Clamp the scrolling speed to the maximum value
                    scrollSpeedY = Math.max(Math.min(scrollSpeedY, maxScrollSpeed), -maxScrollSpeed);
                    scrollSpeedX = Math.max(Math.min(scrollSpeedX, maxScrollSpeed), -maxScrollSpeed);

                    window.scrollBy(scrollSpeedX, scrollSpeedY);
                } else {
                    // Apply deceleration when not dragging
                    scrollSpeedY *= deceleration;
                    scrollSpeedX *= deceleration;

                    // Ensure speeds approach zero more effectively
                    if (Math.abs(scrollSpeedY) < minDeceleration) scrollSpeedY = 0;
                    if (Math.abs(scrollSpeedX) < minDeceleration) scrollSpeedX = 0;

                    // Clamp the scrolling speed to the maximum value
                    scrollSpeedY = Math.max(Math.min(scrollSpeedY, maxScrollSpeed), -maxScrollSpeed);
                    scrollSpeedX = Math.max(Math.min(scrollSpeedX, maxScrollSpeed), -maxScrollSpeed);

                    window.scrollBy(scrollSpeedX, scrollSpeedY);
                }

                requestAnimationFrame(smoothScroll);
            }

            // Mouse events
            window.addEventListener('mousedown', startDrag);
            window.addEventListener('mouseup', endDrag);
            window.addEventListener('mousemove', move);

            // Touch events
            window.addEventListener('touchstart', startDrag);
            window.addEventListener('touchend', endDrag);
            window.addEventListener('touchmove', move);

            smoothScroll();
        }

        // Call the function to set up event handlers
        setupMovementHandlers();


        
        
        
        
        // --- CENTER THE NAV ---   
        const pill1 = document.querySelector('.pill1');
        const pillBox = document.querySelector('.pill-box');
    
        function updateOffset() {
        
            // Get the total width of the viewport
            const totalWidth = window.innerWidth;

            // Get the bounding rectangle of pill1
            const pill1Rect = pill1.getBoundingClientRect();

            // Calculate the center of pill1
            const pill1Center = pill1Rect.left + (pill1Rect.width / 2);

            // Calculate the difference between center of viewport and center of pill1
            const offset = (totalWidth / 2) - pill1Center;
            
            
            pillBox.style.transform = `translateX(${offset}px)`;  
    }

        window.addEventListener('load', () => {
        setTimeout(updateOffset, 0);
    });

      
    
        
         // --- FISHEYE ---    
        const circleFish = document.querySelector('.circle');

        // Add a mousemove event listener to apply fish-eye effect based on mouse position
        document.addEventListener('mousemove', (event) => {
            const mouseXFish = event.clientX;
            const mouseYFish = event.clientY;

            // Get the viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate distance from the cursor to the center of the viewport
            const centerXFish = viewportWidth / 2;
            const centerYFish = viewportHeight / 2;
            const distanceXFish = Math.abs(centerXFish - mouseXFish);
            const distanceYFish = Math.abs(centerYFish - mouseYFish);
            
            // Calculate a scaling factor based on distance from the center
            const maxDistanceFish = Math.sqrt(Math.pow(centerXFish, 2) + Math.pow(centerYFish, 2));
            const distanceFromCenterFish = Math.sqrt(Math.pow(distanceXFish, 2) + Math.pow(distanceYFish, 2));
            
            // Calculate the scale factor (closer to center = larger scale)
            const scaleFactorFish = 1 + (1 - (distanceFromCenterFish / maxDistanceFish)) * 2; // Scale between 1x and 3x
            
            // Adjust background-size based on distance from center
            const newBackgroundSizeFish = `min(${4 * scaleFactorFish}vw, ${4 * scaleFactorFish}vh)`;
            circle.style.backgroundSizeFish = `${newBackgroundSizeFish} ${newBackgroundSizeFish}`;
        });        
        
        
        
        // --- LOG ---
        const Display = document.querySelector('.display');
        Display.textContent = `${0}`;

    </script>
</body>

</html>
